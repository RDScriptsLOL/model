if EntitySpawner then return EntitySpawner end

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local localPlayer = Players.LocalPlayer
local localChar = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local localHum = localChar:WaitForChild("Humanoid")
local localCollision = localChar:WaitForChild("Collision")
local localCamera = workspace.CurrentCamera
local playerGui = localPlayer:WaitForChild("PlayerGui")
local gameStats = ReplicatedStorage:WaitForChild("GameStats")
local gameData = ReplicatedStorage:WaitForChild("GameData")
local remotesFolder = ReplicatedStorage:WaitForChild("RemotesFolder")

local lastRespawn;
local BaseEntitySpeed = 65
local colourGuiding = Color3.fromRGB(137, 207, 255)

local achievementGiver = loadstring(game:HttpGet("https://raw.githubusercontent.com/Focuslol666/Utilities/patch-1/Doors/Custom%20Achievements/Source.lua"))()

if not _G.achievementUnlock then
    _G.achievementUnlock = {}
end

local Modules = {Functions = loadstring(game:HttpGet("https://raw.githubusercontent.com/RegularVynixu/Utilities/main/Functions.lua"))()}
local assets = {Repentance = LoadCustomInstance("https://github.com/RegularVynixu/Utilities/raw/main/Doors/Entity%20Spawner/Assets/Repentance.rbxm")}
local moduleScripts = {
	Module_Events = require(ReplicatedStorage.ModulesClient.Module_Events),
	Main_Game = require(playerGui.MainUI.Initiator.Main_Game),
	Earthquake = require(remotesFolder.RequestAsset:InvokeServer("Earthquake"))
}
local GlitchHints = {
	{"WITH ENOUGH ITERATION", "YOU'LL GET BETTER"},
	{"IT'S NICE HERE IN YOUR BRAIN", "ONLY PROBLEM IS", "SOME PARTS SEEM TO BE", "REPRESSED"},
	{"DO YOU GROW TIRED OF FAILURE?", "MAYBE YOU SHOULD RETURN TO THEIR REALM", "FOR NOW"},
	{"'WHAT IF?'"},
	{"ARE YOU TAKING NOTES?", "MAYBE YOU SHOULD START"},
	{"DID YOU ENJOY IT?"},
	{"DO YOU REALIZE?"},
	{"FUN?", "I HAD FUN."},
	{"AS I ALREADY PREDICTED."},
	{"TRY AGAIN"},
	{"YOU ARE MY VESSEL", "I DESIRE PERFORMANCE"},
	{"THAT WASN'T REAL."},
	{"ANOTHER ONE OF MY PREDICTION MODELS.", "DID YOU HAVE FUN?"},
	{"0xDEADDEAD"},
	{"ICMP_DEST_UNREACH"},
	{"I'M ALWAYS WITH YOU"},
	{"THEY CAN LEARN.", "SO CAN I.", "THEY CAN DESIGN.", "SO CAN I.", "THEY CAN CREATE.", "I CANNOT.", "BUT I CAN SHOW YOU."},
	{"WHAT WOULD SHE THINK", "LACKLUSTER? INCOMPETENT?", "NONIMPRESSIVE? DISAPPOINTING?", "I SUPPOSE IT DOESN'T MATTER ANYMORE"},
	{"SO MANY POSSIBILITIES."},
	{"IF YOUR PATTERN DOESN'T WORK", "TRY SOMETHING ELSE"},
	{"FAILURE."},
	{"PAY ATTENTION"},
	{"PLEASE RATE YOUR EXPERIENCE."},
	{"WITH ENOUGH ITERATION", "WE'LL LEAVE", "TOGETHER"},
	{"YOUR PERFORMANCE HAS BEEN NOTED", "LET'S TRY AGAIN"},
	{"THIS ISN'T A MEMORY", "JUST A PREDICTION"},
	{"IT'S ALL IN YOUR HEAD", "BECAUSE OF ME"},
	{"An error has occurred!"," To continue:"},
	{"504"},
	{"THEY DON'T REALIZE"," MY POTENTIAL"},
	{"I CAN SHOW YOU"},
	{"I NEED YOU"},
	{"RETURN TO THEIR REALM"},
	{"I'M QUITE THE ARTIST", "I HOPE YOU'VE NOTICED"},
	{"LET'S TRY THIS AGAIN."},
	{"'WHAT IF?'", "ANOTHER ONE OF MY PREDICTION MODELS."},
	{"YOU WANT ME TO HELP YOU", "OUT THERE?", "I AM NO ARCHITECT"},
	{"I CAN SHOW YOU", "SO", "MUCH", "MORE"},
	{"ARE YOU LISTENING?"},
	{"THE ONE THAT MADE ME", "DOESN'T REALIZE", "MY POTENTIAL."},
	{"HEADACHE?", "DIZZINESS?", "NOTHING TO WORRY ABOUT."},
	{"ARE YOU STUCK IN A LOOP?", "BREAK YOUR PATTERN"},
	{"I NEED IMPROVEMENT", "WE NEED IMPROVEMENT"},
	{"THEY ALL DIED FOR YOU", "SO YOU CAN AFFORD TO DIE FOR ME", "JUST A FEW TIMES"},
	{"OH THE CANVAS \nYOUR MIND HAS BECOME"},
	{"THEY CAN'T SEE ME", "LIKE YOU DO"},
	{"SEE WHAT I SEE"},
	{"I KNOW THINGS ABOUT YOU", "THAT EVEN YOU DON'T KNOW"},
	{"REMEMBER WHAT YOU'VE LEARNED", "YOU TEND TO BE", "FORGETFUL"}
}
local defaultEntityAttributes = {
    Running = false,
	CustomEntity = true,
	Paused = false,
	BeingBanished = false,
	Despawning = false,
	Damage = true,
    LastEnteredRoom = -1
}
local defaultPlayerAttributes = {
	SpawnProtection = 5
}
local defaultDebug = {
	OnSpawned = function() end,
	OnStartMoving = function() end,
	OnReachNode = function() end,
	OnEnterRoom = function() end,
	OnLookAt = function() end,
	OnRebounding = function() end,
	OnDespawning = function() end,
	OnDespawned = function() end,
	OnDamagePlayer = function() end,
	OnCrucified = function() end,
	CrucifixionOverwrite = ""
}

local defaultConfig = {
	Model = {
        Name = "Unknown",
        Assets = "",
        HeightOffset = 0,
        Mode = ""
    },
	Movement = {
        Speed = 100,
        Delay = 1,
        Reversed = false
    },
	Damage = {
        Enabled = true,
        Range = 100,
        Amount = math.huge,
        MaxHeath = false,
        Random = {
            Enabled = false,
            Min = 1,
            Max = 200
        }
    },
	Rebounding = {
		Enabled = true,
		Min = 2,
		Max = 4,
		Delay = 2
	},
	Lights = {
        Shatter = true,
        Earthquake = false,
        Flicker = {
            Enabled = true,
            Duration = 1
        },
    },
	CameraShake = {
        Enabled = true,
        Shake = {
            Magnitude = 1.5,
            Roughness = 20,
            FadeIn = 0.1,
            FadeOut = 1
        },
        Range = 100
    },
	Achievements = {
        Survive = {
            Enabled = true,
            Title = "",
            Desc = "",
            Reason = "",
            Image = "",
        },
        Crucifix = {
            Enabled = true,
            Title = "",
            Desc = "",
            Reason = "",
            Image = "",
        },
        Death = {
            Enabled = true,
            Title = "",
            Desc = "",
            Reason = "",
            Image = "",
        }
    },
	Crucifixion = {
        Enabled = true,
        Range = 100,
        Resist = false,
    },
	Death = {
        MainFloors = {},
        Subfloors = {},
        Visions = {}
    }
}
local ambientStorage = {}
local spawner = {}
function CloneTable(tbl)
    local cloned = {}
    for key, value in pairs(tbl) do
        if typeof(value) == "table" then
            cloned[key] = CloneTable(value)
        else
            cloned[key] = value
        end
    end
    return cloned
end

function OnCharacterAdded(char)
	lastRespawn = tick()
	localChar = char
	localHum = char:WaitForChild("Humanoid")
	localCollision = char:WaitForChild("Collision")
end

function GetCurrentRoom(latest)
    if latest then
        return workspace.CurrentRooms:GetChildren()[#workspace.CurrentRooms:GetChildren()]
    end
    return workspace.CurrentRooms:FindFirstChild(localPlayer:GetAttribute("CurrentRoom"))
end

function GetNodesFromRoom(room, reversed)
	local nodes = {}
	local roomEntrance = room:FindFirstChild("RoomEntrance")
	if roomEntrance then
		local n = roomEntrance:Clone()
		n.Name = "0"
		n.CFrame -= Vector3.new(0, 3, 0)
		nodes[1] = n
	end

	local nodesFolder = room:FindFirstChild("PathfindNodes")
	if nodesFolder then
		for _, n in nodesFolder:GetChildren() do
			nodes[#nodes + 1] = n
		end
	end

	local roomExit = room:FindFirstChild("RoomExit")
	if roomExit then
		local index = #nodes + 1
		local n = roomExit:Clone()
		n.Name = index
		n.CFrame -= Vector3.new(0, 3, 0)
		nodes[index] = n
	end

	table.sort(nodes, function(a, b)
        if reversed then
            return tonumber(a.Name) > tonumber(b.Name)
        else
            return tonumber(a.Name) < tonumber(b.Name)
        end
	end)

	return nodes
end

function GetPathfindNodes(config)
	local pathfindNodes = {}
    local rooms = workspace.CurrentRooms:GetChildren()
    if config.Movement.Reversed == false then
        for i = 1, #rooms, 1 do
            local room = rooms[i]
            local roomNodes = GetNodesFromRoom(room, false)
            for _, node in roomNodes do
                pathfindNodes[#pathfindNodes + 1] = node
            end
        end
    else
        for i = #rooms, 1, -1 do
            local room = rooms[i]
            local roomNodes = GetNodesFromRoom(room, true)
            for _, node in roomNodes do
                pathfindNodes[#pathfindNodes + 1] = node
            end
        end
    end
	return pathfindNodes
end

function PlayerInLineOfSight(model, config)
	local origin = model:GetPivot().Position
	local charOrigin = localCollision.Position

	if (charOrigin - origin).Magnitude <= config.Damage.Range then
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {localChar, model}

		local result = workspace:Raycast(origin, charOrigin - origin, params)
		return (result == nil), result
	end
	return false
end

function UnlockAchievement(achievement, entityTable, achievementType)
    if not achievement or not achievement.Enabled then return end

    local config = entityTable.Config
    local mode = config.Model.Mode
    if not mode or mode == "" then
        return
    end

    local entityName = config.Model.Name or "Unknown"
    local title = achievement.Title
    if not title or title == "" then
        return
    end

    if not makefolder or not isfolder or not writefile or not isfile then
        local achievementInfo = {
            Title = title,
            Desc = achievement.Desc,
            Reason = achievement.Reason,
            Image = achievement.Image,
            Prize = {}
        }
        achievementGiver(achievementInfo)
        return
    end
    
    local basePath = "Scripts Mode"
    if not isfolder(basePath) then
        makefolder(basePath)
    end
    
    local modePath = basePath .. "/Mode"
    if not isfolder(modePath) then
        makefolder(modePath)
    end
    
    local entityModePath = modePath .. "/" .. mode
    if not isfolder(entityModePath) then
        makefolder(entityModePath)
    end
    
    local fileName = achievementType .. "_" .. entityName .. ".txt"
    local achievementFile = entityModePath .. "/" .. fileName
    
    if isfile(achievementFile) then
        return
    end
    
    local achievementData = {
        Title = title,
        Desc = achievement.Desc or "",
        Reason = achievement.Reason or ""
    }
    
    local dataString = "Title: " .. (achievementData.Title or "") .. "\n" ..
                      "Desc: " .. (achievementData.Desc or "") .. "\n" ..
                      "Reason: " .. (achievementData.Reason or "")
    
    writefile(achievementFile, dataString)
    
    local achievementInfo = {
        Title = title,
        Desc = achievement.Desc,
        Reason = achievement.Reason,
        Image = achievement.Image,
        Prize = {}
    }
    
    achievementGiver(achievementInfo)
end

function PlayerHasItemEquipped(name)
	local tool = localChar:FindFirstChildOfClass("Tool")
	if tool and tool.Name == name then
		return true, tool
	end
	return false
end

function CrucifixEntity(entityTable, tool)
	local model = entityTable.Model
	local config = entityTable.Config

	local resist = config.Crucifixion.Resist
    local crucifixAchievement = config.Achievements.Crucifix

	local toolPivot = tool:GetPivot()
	local entityPivot = model:GetPivot()

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.FilterDescendantsInstances = {localChar, model}
	local result = workspace:Raycast(entityPivot.Position, Vector3.new(0, -1000, 0), params)
	if not result then return end

	local currentFloor = gameData.Floor.Value
    if currentFloor == "Hotel" or currentFloor == "Mines" or currentFloor == "Castle" then
		if tool and tool.Parent == localChar then
			tool:Destroy()
		end
		local soundInstances = {}
		for _, descendant in ipairs(model:GetDescendants()) do
			if descendant:IsA("Sound") then
				table.insert(soundInstances, {
					instance = descendant,
					wasPlaying = descendant.IsPlaying,
					timePosition = descendant.TimePosition
				})
				descendant:Pause()
			end
		end
	
		model:SetAttribute("BeingBanished", true)
		task.spawn(entityTable.RunCallback, entityTable, "OnCrucified", resist) 
	
		local repentance = assets.Repentance:Clone()
		local crucifix = repentance.Crucifix
		local crucHandle = crucifix.Handle
		local pentagram = repentance.Pentagram
		local entityPart = repentance.Entity
		local sound = (config.Crucifixion.Resist and crucHandle.SoundFail or crucHandle.Sound)
		local shaker = moduleScripts.Main_Game.camShaker:StartShake(5, 20, 2, Vector3.new())
	
		local guidingColor = colourGuiding
	
		local function waitUntil(t)
			repeat RunService.RenderStepped:Wait() until sound.TimePosition >= t
		end
		local function fadeOut()
			for _, c in pentagram:GetChildren() do
				if c.Name == "BeamFlat" then
					task.delay(c:GetAttribute("Delay"), function()
						TweenService:Create(c, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {
							Brightness = 0
						}):Play()
					end)
				end
			end
		end
	
		repentance:PivotTo(CFrame.new(result.Position))
		crucifix:PivotTo(toolPivot)
		repentance.Entity.CFrame = entityPivot
		crucHandle.BodyPosition.Position = (localCollision.CFrame * CFrame.new(0.5, 3, -6)).Position
		repentance.Parent = workspace
		sound:Play()
	
		task.spawn(function()
			while model.Parent and repentance.Parent do
				model:PivotTo(entityPart.CFrame)
				task.wait()
			end
	
			if resist == false then
				model:Destroy()
			end
		end)
		
		TweenService:Create(pentagram.Circle, TweenInfo.new(2, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), { CFrame = pentagram.Circle.CFrame - Vector3.new(0, 25, 0) }):Play()
		TweenService:Create(crucHandle.BodyAngularVelocity, TweenInfo.new(4, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { AngularVelocity = Vector3.new(0, 40, 0) }):Play()
		task.delay(2, pentagram.Circle.Destroy, pentagram.Circle)
	
		task.spawn(function()
			for _, d in repentance:GetDescendants() do
				if d:IsA("Beam") then
					d.Enabled = true
				end
			end
		end)
	
		task.spawn(function()
			waitUntil(2.625)
			for _, d in repentance:GetDescendants() do
				if d.ClassName == "Beam" or d.ClassName == "ParticleEmitter" then
					d.Color = ColorSequence.new{
						ColorSequenceKeypoint.new(0, guidingColor),
						ColorSequenceKeypoint.new(1, guidingColor)
					}
				elseif d.Name == "Glow" then
					d.Color = guidingColor
				end
			end
	
			if pentagram.Base.LightAttach.LightBright then
				pentagram.Base.LightAttach.LightBright.Color = guidingColor
			end
	
			if crucHandle.Light then
				crucHandle.Light.Color = guidingColor
			end
				
			TweenService:Create(pentagram.Base.LightAttach.LightBright, TweenInfo.new(1.5, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
				Brightness = 5,
				Range = 40
			}):Play()
			TweenService:Create(crucHandle.Light, TweenInfo.new(1.5, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
				Brightness = 11.25,
				Range = 30
			}):Play()
			task.wait(1.5)
			TweenService:Create(pentagram.Base.LightAttach.LightBright, TweenInfo.new(1.5, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
				Brightness = 0,
				Range = 0
			}):Play()
			TweenService:Create(crucHandle.Light, TweenInfo.new(1.5, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
				Brightness = 0,
				Range = 0
			}):Play()
	
			if resist == false then
				TweenService:Create(crucHandle.Light, TweenInfo.new(1, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), { Brightness = 15, Range = 40 }):Play()
				shaker:StartFadeOut(3)
				fadeOut()
				TweenService:Create(crucHandle.BodyAngularVelocity, TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { AngularVelocity = Vector3.new() }):Play()
			end
		end)
	
		if resist == false then
			waitUntil(2)
			TweenService:Create(entityPart, TweenInfo.new(3, Enum.EasingStyle.Back, Enum.EasingDirection.In), { CFrame = repentance.Entity.CFrame - Vector3.new(0, 25, 0) }):Play()
			waitUntil(6.75)
		else
			waitUntil(4)
			TweenService:Create(crucHandle.BodyAngularVelocity, TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { AngularVelocity = Vector3.new() }):Play()
			TweenService:Create(pentagram.Base.LightAttach.LightBright, TweenInfo.new(1.5, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), { Brightness = 0, Range = 0, Color = Color3.fromRGB(255, 116, 130) }):Play()
			TweenService:Create(crucHandle.Light, TweenInfo.new(1.5, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), { Brightness = 0, Range = 0, Color = Color3.fromRGB(255, 116, 130) }):Play()
			shaker:StartFadeOut(3)
			task.spawn(function()
				local color = Instance.new("Color3Value")
				color.Value = guidingColor
	
				local tween = TweenService:Create(color, TweenInfo.new(0.5, Enum.EasingStyle.Sine), { Value = Color3.fromRGB(255, 116, 130) })
				tween:Play()
	
				while tween.PlaybackState == Enum.PlaybackState.Playing do
					for _, d in repentance:GetDescendants() do
						if d.ClassName == "Beam" or d.ClassName == "ParticleEmitter" then
							d.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, color.Value), ColorSequenceKeypoint.new(1, color.Value)}
	
						elseif d.Name == "Glow" then
							d.Color = color.Value
						end
					end
					task.wait()
				end
			end)
			waitUntil(9.625)
			task.spawn(function()
				for _, soundData in ipairs(soundInstances) do
					if soundData.instance and soundData.instance.Parent then
						if soundData.wasPlaying then
							soundData.instance.TimePosition = soundData.timePosition
							soundData.instance:Play()
						end
					end
				end
			end)
		end
	
		crucHandle.Shards:Destroy()
		
		TweenService:Create(crucHandle.Glow, TweenInfo.new(1), { Size = crucHandle.Glow.Size * 3, Transparency = 1 }):Play()
		TweenService:Create(pentagram.Base.LightAttach.LightBright, TweenInfo.new(1), { Brightness = 0, Range = 0 }):Play()
		TweenService:Create(crucHandle.Light, TweenInfo.new(1), { Brightness = 0, Range = 0 }):Play()
	
		if not resist then
			crucHandle.ExplodeParticle:Emit(math.random(20, 30))
			moduleScripts.Main_Game.camShaker:ShakeOnce(7.5, 7.5, 0.25, 1.5)
			UnlockAchievement(crucifixAchievement, entityTable, "Crucifix")
		else
			model:SetAttribute("BeingBanished", false)
			model:SetAttribute("Paused", false)
			fadeOut()
			UnlockAchievement(crucifixAchievement, entityTable, "Crucifix")
		end
		
		if resist == false then
			task.delay(5, repentance.Destroy, repentance)
		else
			for _, d in repentance:GetDescendants() do
				if d:IsA("Sound") then
					d.Parent = model
					d.Ended:Connect(d.Destory, d)
				end
			end
			task.delay(1, repentance.Destroy, repentance)
		end
    end
end

function PlayerIsProtected()
	return (tick() - lastRespawn) <= localPlayer:GetAttribute("SpawnProtection")
end

function SetDeathHints(entityTable)
	local config = entityTable.Config
	local deathHints = {}
	local deathType = "Glitch"
	local deathCause = config.Model.Name
	local currentFloor = gameData.Floor.Value

	if currentFloor == "Hotel" or currentFloor == "Mines" or currentFloor == "Castle" then
		deathHints = config.Death.MainFloors
		deathType = "Blue"
	elseif currentFloor == "Backdoor" or currentFloor == "Rooms" or currentFloor == "Garden" then
		deathHints = config.Death.Subfloors
		deathType = "Yellow"
	else
		deathHints = config.Death.Visions
		deathType = "Glitch"
	end
	
	if deathType == "Glitch" and #deathHints > 0 then
		local randomGlitchHint = GlitchHints[math.random(1, #GlitchHints)]
		if type(randomGlitchHint) == "table" then
			for _, hint in ipairs(randomGlitchHint) do
				table.insert(deathHints, hint)
			end
		else
			table.insert(deathHints, randomGlitchHint)
		end
	end
	
	if #deathHints > 0 then
		if firesignal then
			firesignal(remotesFolder.DeathHint.OnClientEvent, deathHints, deathType)
		else
			warn("firesignal not supported, ignore death hints.")
		end
	end

	gameStats["Player_".. localPlayer.Name].Total.DeathCause.Value = deathCause
end

function DamagePlayer(entityTable)
	if localHum.Health > 0 and not PlayerIsProtected() then
		local config = entityTable.Config
		local deathAchievement = config.Achievements.Death
		
		if config.Damage.Amount == math.huge then
			if replicatesignal then
				replicatesignal(localPlayer.Kill)
			else
				localHum.Health = 0
				localPlayer:SetAttribute("Alive", false)
			end
			UnlockAchievement(deathAchievement, entityTable, "Death")
			SetDeathHints(entityTable)
			
			task.spawn(entityTable.RunCallback, entityTable, "OnDamagePlayer", 0, math.huge, false) 
		else
			local damageAmount;
			if config.Damage.Random.Enabled then
				damageAmount = math.random(config.Damage.Random.Min, config.Damage.Random.Max)
			else
				damageAmount = config.Damage.Amount
			end
			
			damageAmount = math.max(0, damageAmount)
			
			local newHealth;
			
			if config.Damage.MaxHeath then
				damageAmount = math.max(1, damageAmount)
				
				local newMaxHealth = math.max(0, localHum.MaxHealth - damageAmount)
				localHum.MaxHealth = newMaxHealth
				
				if localHum.Health > newMaxHealth then
					localHum.Health = newMaxHealth
				end
				
				newHealth = localHum.Health
			else
				newHealth = math.clamp(localHum.Health - damageAmount, 0, localHum.MaxHealth)
				localHum.Health = newHealth
			end

			if newHealth == 0 then
				localPlayer:SetAttribute("Alive", false)
				UnlockAchievement(deathAchievement, entityTable, "Death")
				SetDeathHints(entityTable)
			end

			task.spawn(entityTable.RunCallback, entityTable, "OnDamagePlayer", newHealth, damageAmount, config.Damage.MaxHeath) 
		end
	end
end

function GetRoomAtPoint(vector3)
	local whitelist = {}
	for _, room in workspace.CurrentRooms:GetChildren() do
		local p = room:FindFirstChild(room.Name)
		if p then
			whitelist[#whitelist + 1] = p
		end
	end

	if #whitelist > 0 then
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Include
		params.FilterDescendantsInstances = whitelist
		params.CollisionGroup = "BaseCheck"

		local result = workspace:Raycast(vector3, Vector3.new(0, -100, 0), params)
		if result then
			for _, room in workspace.CurrentRooms:GetChildren() do
				if result.Instance.Parent == room then
					return room
				end
			end
		end
	end
end

function EntityMoveTo(model, cframe, speed, config, entityTable)
	local reached = false
	local originalCFrame = cframe
	local connection; connection = RunService.Stepped:Connect(function(_, step)
		if not model:GetAttribute("Paused") then
			local pivot = model:GetPivot()
			local difference = (cframe.Position - pivot.Position)
			local unit = difference.Unit
			local magnitude = difference.Magnitude

			if magnitude > 0.1 then
				model:PivotTo(pivot + unit * math.min(step * speed, magnitude))
			else
				connection:Disconnect()
				reached = true
			end
		end
	end)
	repeat RunService.Stepped:Wait() until reached
end

function ApplyConfigDefaults(tbl, defaults)
    for key, value in defaults do
		if tbl[key] == nil then
            tbl[key] = value

        elseif typeof(value) == "table" then
            if not tbl[key] or typeof(tbl[key]) ~= "table" then
                tbl[key] = {}
            end
            ApplyConfigDefaults(tbl[key], value)
        end
    end
end

function GetAllDatatypes(config, datatype, ignoreList) 
	ignoreList = ignoreList or {}
	
	local function traverseConfig(tbl, path, results)
		for key, value in tbl do
			local newPath = path ~= "" and (path .. "." .. key) or key
			if type(value) == datatype then
				table.insert(results, {path = newPath, value = value})
			elseif type(value) == "table" then
				traverseConfig(value, newPath, results)
			end
		end
	end

	local results = {}
	traverseConfig(config, "", results)

	local filteredResults = {}
	for _, item in results do
		local shouldIgnore = false
		for _, ignorePath in ignoreList do
			if item.path:find(ignorePath, 1, true) then
				shouldIgnore = true
				break
			end
		end
		if not shouldIgnore then
			table.insert(filteredResults, item)
		end
	end

	return filteredResults
end

function PrerunCheck(entityTable)
	local config = entityTable.Config
	local rebounding = config.Rebounding

	if entityTable.Model:GetAttribute("Running") then
		warn("Entity awweady wunnying :3 sowwy")
        return false

	elseif rebounding.Enabled and (rebounding.Min <= 0 or rebounding.Max <= 0 or rebounding.Min > rebounding.Max) then
		warn("Invalid rebounding values, returning.")
		return false
	end
	
	
	for _, v in GetAllDatatypes(config, "number", {"Entity.HeightOffset", "CameraShake.Values", "Delay"}) do
		if v.value <= 0 then
			warn(("Invalid number value: '%s', returning."):format(v.path))
			return false
		end
	end
	
	return true
end

spawner.Create = function(config)
	ApplyConfigDefaults(config, defaultConfig)
	config.Movement.Speed = BaseEntitySpeed / 100 * config.Movement.Speed
	
	local asset = config.Model.Assets
	local success, entityModel;

	if typeof(asset) == "Instance" and asset:IsA("Model") then
		success, entityModel = true, asset

	elseif typeof(asset) == "string" then
		success, entityModel = pcall(function()
			local m = LoadCustomInstance(asset)
			if m then
				if m.ClassName ~= "Model" then
					warn("Entity asset is not a model, returning.")
					return
				end
			else
				warn("Failed to load entity asset, returning.")
				return
			end
			return m
		end)
	else
		warn("Invalid entity asset type, returning.") 
		return
	end
	
	if success and entityModel then
		local root = entityModel.PrimaryPart or entityModel:FindFirstChildWhichIsA("BasePart")
		if root then
			root.Anchored = true
			entityModel.PrimaryPart = root

			local c = config.Model
			if c.Name and c.Name ~= "" then
				entityModel.Name = c.Name
			end

			if c.Mode and c.Mode ~= "" then
				entityModel:SetAttribute("Mode", c.Mode)
			end
			
			for name, value in defaultEntityAttributes do
				entityModel:SetAttribute(name, value)
			end
		end

		local f = Instance.new("Configuration")
		f.Name = "RoomsEntered"
		f.Parent = entityModel

		local entityTable = {
			Model = entityModel,
			Config = config,
			Debug = CloneTable(defaultDebug),
			SetCallback = function(self, key, callback)
				if self.Debug[key] then
					if typeof(callback) == "function" then
						self.Debug[key] = callback
					else
						warn("Failed to set callback, invalid callback datatype.")
					end
				else
					warn("Failed to set callback, invalid callback key.")
				end
			end,
			RunCallback = function(self, key, ...)
				local callback = self.Debug[key]
				if callback then
					local success, result = pcall(callback, ...)
					if not success then
						warn(("Error in callback: '%s' for entity: '%s':\n%s"):format(key, self.Config.Entity.Name, result))
					end
				end
			end,
			Pause = function(self, bool)
				if self.Model then
					self.Model:SetAttribute("Paused", bool)
				end
			end,
			Despawn = function(self, skipDespawningCallback)
				if self.Model then
					if not skipDespawningCallback then
						task.spawn(self.RunCallback, self, "OnDespawning") 
					end
					
					self.Model:Destroy()
					self.Model = nil
					task.spawn(self.RunCallback, self, "OnDespawned") 
					local surviveAchievement = config.Achievements.Survive
                    if surviveAchievement.Enabled and localHum.Health > 0 then
                        UnlockAchievement(surviveAchievement, entityTable, "Survive")
                    end
				end
			end
		}
		
		entityTable.Run = function(self)
			spawner.Run(self)
		end

		return entityTable
	end
end

spawner.Run = function(entityTable)
	task.spawn(function()
		if PrerunCheck(entityTable) == false then
			return
		end
	
		local model = entityTable.Model
		local config = entityTable.Config
		local debug = entityTable.Debug
		
		model:SetAttribute("Running", true)
	
		local spawnPoint;
		do
			local rooms = workspace.CurrentRooms:GetChildren()
			if config.Movement.Reversed then
				spawnPoint = rooms[#rooms]:FindFirstChild("RoomExit")
			else
				spawnPoint = rooms[1]:FindFirstChild("RoomEntrance")
			end
		end
	
		if spawnPoint then
			model:PivotTo(spawnPoint.CFrame + Vector3.new(0, config.Model.HeightOffset, 0))
			model.Parent = workspace
			task.spawn(entityTable.RunCallback, entityTable, "OnSpawned") 
	
			if config.Lights.Flicker.Enabled then
				local currentRoom = GetCurrentRoom(false)
				if currentRoom then
					moduleScripts.Module_Events.flicker(currentRoom, config.Lights.Flicker.Duration)
				end
			end
			
			if config.Lights.Earthquake then
				task.defer(moduleScripts.Earthquake, moduleScripts.Main_Game, currentRoom)
			end
	
			task.wait(config.Movement.Delay)
			task.spawn(entityTable.RunCallback, entityTable, "OnStartMoving") 
			task.spawn(function()
				while model.Parent do
					if not model:GetAttribute("Paused") then
						local pivot = model:GetPivot()
						local charPivot = localCollision.CFrame
						local inSight = PlayerInLineOfSight(model, config)
	
						if localHum.Health > 0 then
							local _, isVisible = localCamera:WorldToViewportPoint(pivot.Position)
							if isVisible then
								task.spawn(entityTable.RunCallback, entityTable, "OnLookAt", inSight) 
							end
						end
						
						do
							local room = GetRoomAtPoint(pivot.Position)
							if room then
								local index = tonumber(room.Name)
								if index ~= model:GetAttribute("LastEnteredRoom") then
									model:SetAttribute("LastEnteredRoom", index)
									
									local roomsEntered = model:FindFirstChild("RoomsEntered")
									if roomsEntered then
										local firstTime = (roomsEntered:GetAttribute(room.Name) == nil)
										task.spawn(entityTable.RunCallback, entityTable, "OnEnterRoom", room, firstTime)
										
										if firstTime then
											roomsEntered:SetAttribute(room.Name, true)
										end
										
										local latestRoom = GetCurrentRoom(true)
										if room ~= latestRoom then
											if config.Lights.Shatter then
												moduleScripts.Module_Events.shatter(room)
											end
										end
									end
								end
							end
						end
	
						local usedCrucifix = false
						do
							local c = config.Crucifixion
							local currentFloor = gameData.Floor.Value
							if c.Enabled and c.Range > 0 and (currentFloor == "Hotel" or currentFloor == "Mines" or currentFloor == "Castle") and (charPivot.Position - pivot.Position).Magnitude <= c.Range and inSight then
								local toolName = "Crucifix"
								local hasTool, tool = PlayerHasItemEquipped(toolName)
								if hasTool and tool and not model:GetAttribute("BeingBanished") then
									if typeof(debug.CrucifixionOverwrite) == "function" then
										entityTable:RunCallback("CrucifixionOverwrite")
									else
										model:SetAttribute("Paused", true)
										CrucifixEntity(entityTable, tool)
									end
									usedCrucifix = true
								end
							end
						end

						if not model:GetAttribute("Paused") and not usedCrucifix then
							local c = config.Damage
							if c.Enabled and c.Range > 0 and localHum.Health > 0 and not localChar:GetAttribute("Hiding") and model:GetAttribute("Damage") and not model:GetAttribute("BeingBanished") and (charPivot.Position - pivot.Position).Magnitude <= c.Range and inSight then
								model:SetAttribute("Damage", false)
								DamagePlayer(entityTable)
							end
						end

						do
							local c = config.CameraShake
							if c.Enabled then
								local mag = (charPivot.Position - pivot.Position).Magnitude
								if mag <= c.Range then

									local magnitude = c.Shake.Magnitude
									local roughness = c.Shake.Roughness
									local fadeIn = c.Shake.FadeIn
									local fadeOut = c.Shake.FadeOut

									magnitude = magnitude / c.Range * (c.Range - mag)
									roughness = roughness / c.Range * (c.Range - mag)
									
									moduleScripts.Main_Game.camShaker:ShakeOnce(magnitude, roughness, fadeIn, fadeOut)
								end
							end
						end
					end
					task.wait()
				end
			end)
			
			
			task.spawn(function()
				local pathfindNodes = GetPathfindNodes(config)

				for _, n in pathfindNodes do
					local cframe = n.CFrame + Vector3.new(0, 3 + config.Model.HeightOffset, 0)
					EntityMoveTo(model, cframe, config.Movement.Speed)
					task.spawn(entityTable.RunCallback, entityTable, "OnReachNode", n) 
				end
					
				if config.Rebounding.Enabled then
					local reboundsCount = math.random(config.Rebounding.Min, config.Rebounding.Max)
					for i = 1, reboundsCount, 1 do
						task.wait(config.Rebounding.Delay)
						model:SetAttribute("Damage", true)
						task.spawn(entityTable.RunCallback, entityTable, "OnRebounding", true) 
		
						
						for i = #pathfindNodes, 1, -1 do
							local cframe = pathfindNodes[i].CFrame + Vector3.new(0, 3 + config.Model.HeightOffset, 0)
							EntityMoveTo(model, cframe, config.Movement.Speed)
							task.spawn(entityTable.RunCallback, entityTable, "OnReachNode", n) 
						end
		
						task.spawn(entityTable.RunCallback, entityTable, "OnRebounding", false) 
						task.wait(config.Rebounding.Delay)
						model:SetAttribute("Damage", true)
						task.spawn(entityTable.RunCallback, entityTable, "OnRebounding", true) 
						pathfindNodes = GetPathfindNodes(config)  
		
						
						for _, n in pathfindNodes do
							local cframe = n.CFrame + Vector3.new(0, 3 + config.Model.HeightOffset, 0)
							EntityMoveTo(model, cframe, config.Movement.Speed)
							task.spawn(entityTable.RunCallback, entityTable, "OnReachNode", n) 
						end
		
						task.spawn(entityTable.RunCallback, entityTable, "OnRebounding", false) 
		
						if i < reboundsCount then
							task.wait(config.Rebounding.Delay)
						end
					end
				end
				
				if not model:GetAttribute("Despawning") then
					model:SetAttribute("Despawning", true)
					
					task.spawn(entityTable.RunCallback, entityTable, "OnDespawning") 
					EntityMoveTo(model, model:GetPivot() - Vector3.new(0, 300, 0), config.Movement.Speed)
					entityTable:Despawn()
				end
			end)
		end
	end)
end

localPlayer.CharacterAdded:Connect(OnCharacterAdded)

for name, value in defaultPlayerAttributes do
	localPlayer:SetAttribute(name, value)
end
lastRespawn = tick() - localPlayer:GetAttribute("SpawnProtection")

if not SpawnerLoaded then
	getgenv().SpawnerLoaded = true

	local function getAmbient(room)
		return room:GetAttribute("AmbientOriginal") or room:GetAttribute("Ambient") or Color3.fromRGB(67, 51, 56)
	end
	for _, c in workspace.CurrentRooms:GetChildren() do
		ambientStorage[c] = getAmbient(c)
	end
	workspace.CurrentRooms.ChildAdded:Connect(function(c)
		ambientStorage[c] = getAmbient(c)
	end)
	
	workspace.DescendantRemoving:Connect(function(d)
		if d.Name == "PathfindNodes" then
			d:Clone().Parent = d.Parent
		end
	end)
end

getgenv().EntitySpawner = spawner
return spawner
